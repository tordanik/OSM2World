/* Simple fragment shader for drawing a 2d geometry with texture to screen
 */ 
#version 140


uniform vec3 sunVector;
uniform float sunIntensity;

// How much the atmosphere scatters each channel
uniform vec3 Kr;

uniform float step_count = 10.0;


in vec3 cubemapCoord;
 
// output to buffer
out vec4 color;

// Calculates how much light is scattered in a direction where
// alpha is the angle between the original direction and the
// new direction
float phase(float alpha, float g){
	float a = 3.0*(1.0-g*g);
	float b = 2.0*(2.0+g*g);
	float c = 1.0+alpha*alpha;
	float d = pow(1.0+g*g-2.0*g*alpha, 1.5);
	if(abs(d) < 0.0000001) d = 0.0000001;
	return (a/b)*(c/d);
}

// Calculates how far a ray at a certain altitude has to travel a certain
// direction before it leaves the atmosphere where 0 is the center of the
// earth and 1 is the edge of the atmosphere
float atmospheric_depth(float alt, vec3 dir){
	float d = dir.y;
	return sqrt(alt*alt * (d*d-1) + 1) - alt*d;
}

// Calculates how much light is blocked by the horizon
float horizon_extinction(vec3 position, vec3 dir, float radius){
	float u = dot(dir, -position);
	if(u<0.0){
		return 1.0;
	}

	vec3 near = position + u*dir;
	if(length(near) < radius){
		return 0.0;
	}else{
		vec3 v2 = normalize(near)*radius - position;
		float diff = acos(dot(normalize(v2), dir));
		return smoothstep(0.0, 1.0, pow(diff*2.0, 3.0));
	}
}


// color - color * Kr^(factor/distance)
vec3 extinction(float dist, vec3 color, float factor){
	if(dist < 0.0000001) return color;
	return color-color*pow(Kr, vec3(factor/dist));
}

void main()
{
	float rayleigh_brightness = 0.7;
	float mie_brightness = 1.0;

	// Ratio of earth radius to radius + atmosphere
	float surface_height = 0.9953;
	float scatter_strength = 0.1;

	// Size of mie scattering particles
	float mie_distribution = 0.99995;

	// Calculate the vector from the camera to the fragment
	vec3 eyeVector = normalize(cubemapCoord);

	// Calculates a factor for each type of scattering based on the size
	// of the particles and the angle between the sun and view directions
	float alpha = dot(eyeVector, sunVector);
	float rayleigh_phase = phase(alpha, 0.0);
	float mie_phase = phase(alpha, mie_distribution);


	// Calculate how big steps we should take so that there are exactly step_count
	// steps between the eye and the edge of the atmosphere
	vec3 eye_position = vec3(0.0, surface_height, 0.0);
	float eye_depth = atmospheric_depth(eye_position.y, eyeVector.xyz);
	float step_length = eye_depth / float(step_count);

	vec3 rayleigh_collected = vec3(0.0, 0.0, 0.0);
	vec3 mie_collected = vec3(0.0, 0.0, 0.0);

	for(int i=0; i<step_count; i++){
		// Calculate the sample position in worldspace
		float sample_distance = step_length*float(i);
		vec3 position = eye_position + eyeVector.xyz*sample_distance;

		// How much light from the sun to the sample point is extincted
		// by the horizon
		float sun_extinction = horizon_extinction(
				position, sunVector, surface_height-0.01
			);

		// How much of the ray cast from the eye to the sun is in the atmosphere
		float sample_depth = atmospheric_depth(position.y, sunVector);

		// Amount of sunlight that makes it through the atmosphere to the sample position
		vec3 influx = extinction(sample_depth, vec3(sunIntensity), scatter_strength) * sun_extinction;

		// Amount of light that is in-scattered due to each type of scattering and makes it through
		// the atmosphere from the sample point to the viewer
		rayleigh_collected += extinction(sample_distance, Kr * influx * rayleigh_phase, scatter_strength);
		mie_collected += extinction(sample_distance, influx * mie_phase, scatter_strength);
	}

	// Calculate the horizon
	float eye_extinction = horizon_extinction(
			    eye_position, eyeVector.xyz, surface_height - 0.01
			);

	// Apply the horizon and scale the result
	rayleigh_collected = (
			rayleigh_collected *
			eye_extinction
		) / step_count;

	mie_collected = (
			mie_collected *
			eye_extinction
		) / step_count;


	// Calculate the final color by apply the amount of light that is inscattered
	color = vec4(
			mie_brightness * mie_collected +
			rayleigh_brightness * rayleigh_collected, 1.0
	);

} 

