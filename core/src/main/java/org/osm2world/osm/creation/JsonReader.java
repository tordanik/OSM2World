package org.osm2world.osm.creation;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.osm2world.osm.data.OSMData;

import com.eclipsesource.json.JsonObject;
import com.eclipsesource.json.JsonValue;
import com.slimjars.dist.gnu.trove.list.TLongList;
import com.slimjars.dist.gnu.trove.list.array.TLongArrayList;

import de.topobyte.osm4j.core.model.iface.*;
import de.topobyte.osm4j.core.model.impl.*;

/**
 * Parses OSM JSON files such as those generated by Overpass API
 * (see the <a href=https://dev.overpass-api.de/output_formats.html#json>Overpass API documentation</a>)
 */
public abstract class JsonReader implements OSMDataReader {

	protected abstract JsonValue getJsonRoot() throws IOException;

	@Override
	public OSMData getAllData() throws IOException {

		try {

			JsonValue rootValue = getJsonRoot();
			JsonObject root = rootValue.asObject();

			if (0.6 != root.getDouble("version", 0)) {
				throw new IOException("Unsupported OSM JSON version");
			}

			Collection<OsmBounds> bounds = new ArrayList<>();

			Collection<OsmNode> nodes = new ArrayList<>();
			Collection<OsmWay> ways = new ArrayList<>();
			Collection<OsmRelation> relations = new ArrayList<>();

			for (JsonValue element : root.get("elements").asArray()) {
				if (element instanceof JsonObject e) {

					if (e.get("id") == null || !e.get("id").isNumber()) continue;

					long id = e.getLong("id", Long.MIN_VALUE);

					List<Tag> tags = new ArrayList<>();
					if (e.get("tags") instanceof JsonObject ts) {
						for (var t : ts) {
							tags.add(new Tag(t.getName(), t.getValue().asString()));
						}
					}

					switch (e.get("type").asString()) {

						case "node" ->
							nodes.add(new Node(id,
									e.getDouble("lon", Double.NaN),
									e.getDouble("lat", Double.NaN),
									tags));

						case "way" -> {
							TLongList nodeIds = new TLongArrayList();
							for (JsonValue node : e.get("nodes").asArray()) {
								nodeIds.add(node.asLong());
							}
							ways.add(new Way(id, nodeIds, tags));
						}

						case "relation" -> {
							List<OsmRelationMember> members = new ArrayList<>();
							for (JsonValue member : e.get("members").asArray()) {
								if (member instanceof JsonObject m) {
									EntityType entityType = switch (m.get("type").asString()) {
										case "node" -> EntityType.Node;
										case "way" -> EntityType.Way;
										case "relation" -> EntityType.Relation;
										default -> throw new IOException("Invalid member type for r " + id + ": "
												+ member.asString());
									};
									long ref = m.getLong("ref", Long.MIN_VALUE);
									if (ref != Long.MIN_VALUE) {
										members.add(new RelationMember(
												ref,
												entityType,
												m.getString("role", "")));
									}
								}
							}
							relations.add(new Relation(id, members, tags));
						}

						default -> throw new IOException("Unsupported OSM element type: " + e);

					}

				}
			}

			return new OSMData(bounds, nodes, ways, relations);

		} catch (UnsupportedOperationException e) {
			// occurs if the JSON has an unexpected structure
			throw new IOException(e);
		}

	}

}
