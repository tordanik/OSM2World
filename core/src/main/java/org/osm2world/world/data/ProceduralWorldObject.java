package org.osm2world.world.data;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.Function;

import javax.annotation.Nullable;

import org.osm2world.math.VectorXZ;
import org.osm2world.target.CommonTarget;
import org.osm2world.target.common.mesh.LODRange;
import org.osm2world.target.common.mesh.LevelOfDetail;
import org.osm2world.target.common.mesh.Mesh;
import org.osm2world.target.common.model.ModelInstance;
import org.osm2world.world.attachment.AttachmentSurface;

/**
 * a model which is generated by code during runtime,
 * rather than being loaded as a static asset
 */
public interface ProceduralWorldObject extends WorldObject {

	void buildMeshesAndModels(Target target);

	class Target implements CommonTarget {

		protected final List<Mesh> meshes = new ArrayList<>();
		protected final List<ModelInstance> subModels = new ArrayList<>();
		protected final List<AttachmentSurface> attachmentSurfaces = new ArrayList<>();

		private @Nullable LODRange currentLodRange = null;
		private List<String> currentAttachmentTypes = List.of();
		private Function<VectorXZ, Double> currentBaseEleFunction = null;

		public @Nullable LODRange getCurrentLodRange() {
			return currentLodRange;
		}

		public void setCurrentLodRange(@Nullable LODRange lodRange) {
			this.currentLodRange = lodRange;
		}

		public void setCurrentLodRange(LevelOfDetail minLod, LevelOfDetail maxLod) {
			this.setCurrentLodRange(new LODRange(minLod, maxLod));
		}

		public void setCurrentAttachmentTypes(String... attachmentTypes) {
			setCurrentAttachmentTypes(null, attachmentTypes);
		}

		public void setCurrentAttachmentTypes(@Nullable Function<VectorXZ, Double> baseEleFunction,
				String... attachmentTypes) {
			this.currentBaseEleFunction = baseEleFunction;
			this.currentAttachmentTypes = List.of(attachmentTypes);
		}

		@Override
		public void drawMesh(Mesh mesh) {

			if (currentLodRange == null) {
				meshes.add(mesh);
			} else {
				meshes.add(new Mesh(mesh.geometry, mesh.material, currentLodRange.min(), currentLodRange.max()));
			}

			if (!currentAttachmentTypes.isEmpty()) {
				attachmentSurfaces.add(AttachmentSurface.fromMeshes(currentAttachmentTypes, List.of(mesh), currentBaseEleFunction));
			}

		}

		public void addSubModel(ModelInstance subModel) {
			subModels.add(subModel);
		}

	}

	@Override
	default List<Mesh> buildMeshes() {
		var target = new Target();
		buildMeshesAndModels(target);
		return target.meshes;
	}

	@Override
	default List<ModelInstance> getSubModels() {
		var target = new Target();
		buildMeshesAndModels(target);
		return target.subModels;
	}

	@Override
	default Collection<AttachmentSurface> getAttachmentSurfaces() {
		var target = new Target();
		buildMeshesAndModels(target);
		return target.attachmentSurfaces;
	}
}
